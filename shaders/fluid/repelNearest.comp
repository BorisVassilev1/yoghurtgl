layout(local_size_x = 128) in;

#include <fluid.glsl>

layout(std430, binding = 1) volatile coherent restrict buffer ParticleBuffer {
	Particle particleData[];
};

layout(binding = 2) restrict readonly buffer Hashes {
	uint hashData[]; // assume sorted
};

layout(binding = 3) restrict readonly buffer lookupBuffer {
	uint lookup[];
};

ivec3 offsets[] = {
	ivec3(-1, -1, -1),
	ivec3(-1, -1, 0),
	ivec3(-1, -1, 1),
	ivec3(-1, 0, -1),
	ivec3(-1, 0, 0),
	ivec3(-1, 0, 1),
	ivec3(-1, 1, -1),
	ivec3(-1, 1, 0),
	ivec3(-1, 1, 1),
	ivec3(0, -1, -1),
	ivec3(0, -1, 0),
	ivec3(0, -1, 1),
	ivec3(0, 0, -1),
	ivec3(0, 0, 0),
	ivec3(0, 0, 1),
	ivec3(0, 1, -1),
	ivec3(0, 1, 0),
	ivec3(0, 1, 1),
	ivec3(1, -1, -1),
	ivec3(1, -1, 0),
	ivec3(1, -1, 1),
	ivec3(1, 0, -1),
	ivec3(1, 0, 0),
	ivec3(1, 0, 1),
	ivec3(1, 1, -1),
	ivec3(1, 1, 0),
	ivec3(1, 1, 1),
};

void main() {
	uvec3 invID = gl_GlobalInvocationID;
	uint id = invID.x;

	Particle p1 = particleData[id];

	uint hash = spatialHash(p1.position);

	//p1.velocity = vec3(0.0f, -0.9, 0.0f); // apply gravity

	ivec3 cell = ivec3(p1.position / cellSize);
	for (uint k = 0; k < 27; ++k) {
		ivec3 localcell = cell + offsets[k];
		uint localHash = spatialHash(localcell);
		
		uint lookupStart = lookup[localHash];
		if(lookupStart == -1) continue;

		for (uint i = lookupStart; hashData[2 * i] == localHash; ++i) {
			uint particleHash = hashData[2 * i]; // not needed
			uint particleId = hashData[2 * i + 1];

			if (particleId == id) continue;

			Particle p2 = particleData[particleId];
			vec3 diff = p1.position - p2.position;
			float dist = length(diff);
			if (dist < 0.99f) {
				vec3 dir = normalize(diff);
				float force = 1.0f / (dist * dist + 0.01f); // repulsion force
				//p1.velocity += clamp(dir * force * 0.1f, -vec3(10), vec3(10)); // apply repulsion force
				//p1.velocity += dir * force * 0.3f;
				//p1.velocity -= min(0, dot(p1.velocity, dir)) * dir;
				//p1.position += dir * (0.99f - dist) * 0.1f;
			}

		}

	}
	//p1.velocity = clamp(p1.velocity, -vec3(5.0f), vec3(5.0f)); // limit velocity
	//p1.velocity *= 0.99f; // apply damping

	particleData[id] = p1;
}
