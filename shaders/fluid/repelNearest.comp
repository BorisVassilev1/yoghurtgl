layout(local_size_x = 128) in;

#include <fluid.glsl>

layout(std430, binding = 1) restrict readonly buffer ParticleBufferIn {
	Particle particleDataIn[];
};

layout(binding = 2) restrict readonly buffer Hashes {
	uint hashData[]; // assume sorted
};

layout(binding = 3) restrict readonly buffer lookupBuffer {
	uint lookup[];
};

layout(std430, binding = 4) restrict writeonly buffer ParticleBufferOut {
	Particle particleDataOut[];
};

uniform vec3 b_min;
uniform vec3 b_max;

ivec3 offsets[] = {
	ivec3(-1, -1, -1),
	ivec3(-1, -1, 0),
	ivec3(-1, -1, 1),
	ivec3(-1, 0, -1),
	ivec3(-1, 0, 0),
	ivec3(-1, 0, 1),
	ivec3(-1, 1, -1),
	ivec3(-1, 1, 0),
	ivec3(-1, 1, 1),
	ivec3(0, -1, -1),
	ivec3(0, -1, 0),
	ivec3(0, -1, 1),
	ivec3(0, 0, -1),
	ivec3(0, 0, 0),
	ivec3(0, 0, 1),
	ivec3(0, 1, -1),
	ivec3(0, 1, 0),
	ivec3(0, 1, 1),
	ivec3(1, -1, -1),
	ivec3(1, -1, 0),
	ivec3(1, -1, 1),
	ivec3(1, 0, -1),
	ivec3(1, 0, 0),
	ivec3(1, 0, 1),
	ivec3(1, 1, -1),
	ivec3(1, 1, 0),
	ivec3(1, 1, 1),
};

void main() {
	uvec3 invID = gl_GlobalInvocationID;
	uint id = invID.x;

	if(id >= N) return;

	Particle p1 = particleDataIn[id];

	uint hash = spatialHash(p1.position);

	ivec3 cell = ivec3(floor(p1.position / cellSize));
	vec3 move = vec3(0.0f);
	for (uint k = 0; k < 27; ++k) {
		ivec3 localcell = cell + offsets[k];
		uint localHash = spatialHash(localcell);
		
		uint lookupStart = lookup[localHash];
		if(lookupStart == -1) continue;

		for (uint i = lookupStart; hashData[2 * i] == localHash; ++i) {
			uint particleHash = hashData[2 * i]; // not needed
			uint particleId = hashData[2 * i + 1];

			if (particleId == id) continue;

			Particle p2 = particleDataIn[particleId];
			vec3 diff = p1.position - p2.position;
			float dist = length(diff);
			if (dist < cellSize && dist > EPS) {
				vec3 dir = normalize(diff);
				move += dir * (cellSize - dist) * 0.1f;
			}

		}

	}
	p1.position += move;
	p1.position = clamp(p1.position, b_min , b_max);

	particleDataOut[id] = p1;
}
