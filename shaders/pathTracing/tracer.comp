#version 460

#include <pathTracing.glsl>

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 1) uniform image2D img_output;

// whether or not to account triangle geometry when tracing.
uniform bool do_trace_geometry = false;

uniform bool do_trace_spheres = true;

// maximum number of bounces for a ray
uniform int max_bounces;

// adds the current sample to the texture.
void write_sample(in ivec2 pixel_coords, in vec4 color) {
	vec4 current = imageLoad(img_output, pixel_coords);
	imageStore(img_output, pixel_coords, current + color);
}

// gets the index of the left child of a node in a heap tree
int left(in int index) { return 2 * index; }

// gets the index of the right child of a node in a heap tree
int right(in int index) { return 2 * index + 1; }

// gets the idex of the parent of a node in a heap tree
int parent(in int index) { return index / 2; }

// gets the "closest node to the right". If a node is a left child of another, its sibling is returned.
// if not, the tree is rearched for its lowest parent that is a left child. Then that parent's sibling is returned.
int right_sibling(in int index) {
	int zeros_mask = ~index;
	int res		   = index >> (int(log2(zeros_mask ^ (zeros_mask & (zeros_mask - 1)))));
	return res + int(res != 1);
}

// traces a ray through the geometry
void trace_geometry(in Ray ray, inout RayHit hit) {
	int		 index = 1;		// this is the root of the tree. The traversion functions work better this way
	BVHNode	 node;			// current node
	Triangle t;				// current triangle
	bool	 res;			// has the ray hit the current AABB

	bool must_break = false;
	while (!must_break) {
		node = nodes[index - 1];
		res	 = intersectAABB(ray, node.box);	 // check for intersection with the AABB

		if (res && node.obj_index != -1) {		  // if a node that contains an object (triangle) is hit
			t = get_triangle(node.obj_index);	  // this is inefficient because the triangle normal is never needed if
												  // there is no intersectionq
			intersectTriangle(ray, t, hit);
		}
		// don't ask me what is this. It has no if-s and works.
		index = int(mix(right_sibling(index), left(index), !((res && node.obj_index != -1) || !res)));

		// if index points to the
		must_break = (index == 1);
	}
}

// test for intersections with everything in the scene
void intersect_scene(in Ray ray, inout RayHit hit) {
	intersectGroundPlane(ray, -0.5, hit);

	if (do_trace_spheres) {
		for (int s = 0; s < spheresCount; s++) {
			intersectSphere(ray, s, hit);
		}
		// intersectSphere(ray, sphs[2], hit);
		// intersectSphere(ray, Sphere(vec4(-1.8, 0, 0.8, 1.0), vec4(10., 10., 0., 1.0), 0.2, 0), hit);
	}

	for (uint b = 0; b < boxesCount; ++b) {
		intersectBox(ray, b, hit);
	}

	// if(do_trace_geometry) {
	// 	trace_geometry(ray, hit);
	// }
}

vec3 lerp4vec(vec3 v00, vec3 v10, vec3 v01, vec3 v11, float x, float y) {
	return mix(mix(v00, v01, x), mix(v10, v11, x), y);
}

uniform float aperture	 = 0.0;
uniform float focus_dist = 3.1;

vec3 cam_pos = (cameraMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

// TODO: fix depth of field effect!!!
void get_ray(inout Ray ray, in vec3 cam_pos, in ivec2 pixel_coords, in vec2 pixel_position, uint random_seed) {
	vec2 ray_coords = vec2(pixel_position.x + (randomFloat(random_seed)) / resolution.x,
						   pixel_position.y + (randomFloat(random_seed)) / resolution.y);

	ray_coords = ray_coords * 2. - 1.;

	vec3 ray_dir =
		normalize((vec4(ray_coords.x, -ray_coords.y * aspect, -1 / tan(fov / 2) * aspect, 0.0) * cameraMatrix).xyz);

	ray = Ray(cam_pos, ray_dir);
}

void computeHitInfo(out HitInfo info, in RayHit hit, in Ray ray) {
	info.pos  = ray.origin + ray.direction * hit.dist;
	info.dist = hit.dist;
	if (hit.type == 0) return;
	if (hit.type == 1) {
		info.normal		 = vec3(0.0, 1.0, 0.0);
		float d			 = dot(ray.direction, info.normal);
		info.isFrontFace = step(d, 0.0);
		info.normal		 = (info.isFrontFace * 2.0 - 1.0) * info.normal;
		info.matIdx		 = 0;
		return;
	}
	if (hit.type == 2) {
		Sphere sphere	 = sphs[hit.objIdx];
		info.normal		 = (info.pos - sphere.position.xyz) / sphere.radius;
		info.isFrontFace = step(dot(info.normal, ray.direction), 0.);
		info.normal		 = (info.isFrontFace * 2. - 1.) * info.normal;
		info.matIdx		 = sphere.matIdx;
		return;
	}
	if (hit.type == 3) {
		info.matIdx = geometryMaterialIdx;
		return;
	}
	if (hit.type == 4) {
		Box box = boxes[hit.objIdx];

		vec3 diffmin = abs(info.pos - box.min);
		vec3 diffmax = abs(info.pos - box.max);

		info.normal = step(diffmax, vec3(phi)) - step(diffmin, vec3(phi));
		normalize(info.normal);

		info.isFrontFace = step(dot(info.normal, ray.direction), 0);
		info.normal		 = (float(info.isFrontFace) * 2. - 1.) * info.normal;

		info.matIdx = box.matIdx;
		return;
	}
}

uniform vec3 sun_direction = normalize(vec3(1., 2., 1.));

void main() {
	vec4  pixel			 = vec4(0.0, 0.0, 0.0, 1.0);			// the pixel value
	ivec2 pixel_coords	 = ivec2(gl_GlobalInvocationID.xy);		// the pixel position of the current 'fragment'
	vec2  pixel_position = pixel_coords / resolution;			// pixel position mapped to [0, 1)

	// get the unique random seed for the pixel.
	uint random_seed_full = pixel_coords.x + pixel_coords.y * uint(resolution.x) + random_seed;
	// uint random_seed_full = random_seed;

	Ray	 ray;	  // the current ray being traced
	vec3 attenuation = vec3(1.);
	get_ray(ray, cam_pos, pixel_coords, pixel_position, random_seed_full);

	for (int i = 0; i < max_bounces; i++) {
		// initialize the hit object
		RayHit hit;
		hit.dist = FLOAT_MAX;
		hit.type = 0;

		// test intersections
		intersect_scene(ray, hit);

		// if hit the sky, write sky color and exit
		if (hit.type == 0) {
			pixel += vec4(get_sky_color(ray) * attenuation, 1.0f);
			break;
		}

		HitInfo info;
		computeHitInfo(info, hit, ray);

		Material mat = materials[info.matIdx];

		// do absorption if we are hitting from inside the object
		if (info.isFrontFace == 0.0f) { attenuation *= exp(-mat.transparency_color * info.dist); }

		// get the pre-fresnel chances
		float specularChance   = mat.specular_chance;
		float refractionChance = mat.refraction_chance;

		// take fresnel into account for specularChance and adjust other chances.
		// specular takes priority.
		// chanceMultiplier makes sure we keep diffuse / refraction ratio the same.
		float rayProbability = 1.0f;
		// if (specularChance > 0.0f) {
			specularChance = fresnelReflectAmount(info.isFrontFace == 1.0f ? 1.0f : mat.ior,
												  info.isFrontFace == 1.0f ? mat.ior : 1.0f, ray.direction, info.normal,
												  mat.specular_chance, 1.0f);

			float chanceMultiplier = (1.0f - specularChance) / (1.0f - mat.specular_chance);
			refractionChance *= chanceMultiplier;

			// if(refractionChance == 0.0) {
			// 	pixel += vec4(1.0, 0., 0., 0.0);
			// }
		// }

		// calculate whether we are going to do a diffuse, specular, or refractive ray
		float doSpecular	= 0.0f;
		float doRefraction	= 0.0f;
		float raySelectRoll = randomFloat(random_seed_full);
		if (specularChance > 0.0f && raySelectRoll < specularChance) { // specular reflection
			doSpecular	   = 1.0f;
			rayProbability = specularChance;

			// if(info.normal == vec3(0.0, 0.0, 0.0)) {
			// 	pixel += vec4(1.0, 0.0, 0.0, 1.0);
			// }

			// pixel += vec4(info.normal, 1.0);
		} else if (refractionChance > 0.0f && raySelectRoll < specularChance + refractionChance) { // refraction
			doRefraction   = 1.0f;
			rayProbability = refractionChance;

			// pixel += vec4(info.normal, 1.0);
		} else { // lambertian disperse
			rayProbability = 1.0f - (specularChance + refractionChance);
			
			// pixel += vec4(info.normal, 1.0);
		}

		// avoid numerical issues causing a divide by zero, or nearly so (more important later, when we add refraction)
		rayProbability = max(rayProbability, 0.001f);

		// update the ray position
		if (doRefraction == 1.0f) {
			ray.origin = info.pos - info.normal * phi;
		} else {
			ray.origin = info.pos + info.normal * phi;
		}

		// Calculate a new ray direction.
		// Diffuse uses a normal oriented cosine weighted hemisphere sample.
		// Perfectly smooth specular uses the reflection ray.
		// Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared
		// Squaring the roughness is just a convention to make roughness feel more linear perceptually.
		vec3 diffuseRayDir = cosWeightedHemissphereDir(info.normal, random_seed_full);

		vec3 specularRayDir = reflect(ray.direction, info.normal);
		specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, mat.specular_roughness * mat.specular_roughness));

		vec3 refractionRayDir = refract(ray.direction, info.normal, info.isFrontFace == 1.0 ? 1.0f / mat.ior : mat.ior);
		
		if(refractionRayDir == vec3(0.)) {
			refractionRayDir = vec3(1.0, 0.0, 0.0);
		}
		
		refractionRayDir =
			normalize(mix(refractionRayDir, -diffuseRayDir, mat.refraction_roughness * mat.refraction_roughness));


		ray.direction = mix(diffuseRayDir, specularRayDir, doSpecular);
		ray.direction = mix(ray.direction, refractionRayDir, doRefraction);

		// emission
		pixel += vec4(mat.emission * attenuation, 0);

		// update the colorMultiplier. refraction doesn't alter the color until we hit the next thing, so we can do
		// light absorption over distance.
		if (doRefraction == 0.0f) attenuation *= mix(mat.albedo, mat.specular_color, doSpecular);

		attenuation /= rayProbability;

		// Russian Roulette
		// As the throughput gets smaller, the ray is more likely to get terminated early.
		// Survivors have their value boosted to make up for fewer samples being in the average.
		{
			float p = max(attenuation.r, max(attenuation.g, attenuation.b));
			if (randomFloat(random_seed_full) > p) { break; }

			// Add the energy we 'lose' by randomly terminating paths
			attenuation *= 1.0f / p;
		}
	}

	write_sample(pixel_coords, pixel);
}
