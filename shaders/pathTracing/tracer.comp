#version 460

#include <pathTracing.glsl>

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 1) uniform image2D img_output;

uniform int spheres_count = 0;

layout(binding = 1) uniform spheres { Sphere sphs[40]; };

// whether or not to account triangle geometry when tracing.
uniform bool do_trace_geometry = false;

uniform bool do_trace_spheres = true;

// maximum number of bounces for a ray
uniform int max_bounces;

// adds the current sample to the texture.
void write_sample(in ivec2 pixel_coords, in vec4 color) {
	vec4 current = imageLoad(img_output, pixel_coords);
	imageStore(img_output, pixel_coords, current + color);
}

// gets the index of the left child of a node in a heap tree
int left(in int index) { return 2 * index; }

// gets the index of the right child of a node in a heap tree
int right(in int index) { return 2 * index + 1; }

// gets the idex of the parent of a node in a heap tree
int parent(in int index) { return index / 2; }

// gets the "closest node to the right". If a node is a left child of another, its sibling is returned.
// if not, the tree is rearched for its lowest parent that is a left child. Then that parent's sibling is returned.
int right_sibling(in int index) {
	int zeros_mask = ~index;
	int res		   = index >> (int(log2(zeros_mask ^ (zeros_mask & (zeros_mask - 1)))));
	return res + int(res != 1);
}

// traces a ray through the geometry
void trace_geometry(in Ray ray, inout RayHit hit) {
	int		 index = 1;		// this is the root of the tree. The traversion functions work better this way
	BVHNode	 node;			// current node
	Triangle t;				// current triangle
	bool	 res;			// has the ray hit the current AABB

	bool must_break = false;
	while (!must_break) {
		node = nodes[index - 1];
		res	 = intersectAABB(ray, node.box);	 // check for intersection with the AABB

		if (res && node.obj_index != -1) {		  // if a node that contains an object (triangle) is hit
			t = get_triangle(node.obj_index);	  // this is inefficient because the triangle normal is never needed if
												  // there is no intersectionq
			intersectTriangle(ray, t, hit);
		}
		// don't ask me what is this. It has no if-s and works.
		index = int(mix(right_sibling(index), left(index), !((res && node.obj_index != -1) || !res)));

		// if index points to the
		must_break = (index == 1);
	}
}

// test for intersections with everything in the scene
void intersect_scene(in Ray ray, inout RayHit hit) {
	// TODO: When the ray hits an object it should not write all the object data to the RayHit
	
	intersectGroundPlane(ray, -0.5, hit);
	for (int s = 0; s < 4; s++) {
		intersectSphere(ray, sphs[s], hit);
	}

	if (do_trace_spheres) {
		for (int s = 4; s < spheres_count; s++) {
			intersectSphere(ray, sphs[s], hit);
		}

		// intersectSphere(ray, sphs[2], hit);
		// intersectSphere(ray, Sphere(vec4(-1.8, 0, 0.8, 1.0), vec4(10., 10., 0., 1.0), 0.2, 0), hit);
	}

	// if(do_trace_geometry) {
	// 	trace_geometry(ray, hit);
	// }
}

vec3 lerp4vec(vec3 v00, vec3 v10, vec3 v01, vec3 v11, float x, float y) {
	return mix(mix(v00, v01, x), mix(v10, v11, x), y);
}

uniform float aperture	 = 0.0;
uniform float focus_dist = 3.1;

vec3 cam_pos = (cameraMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

// TODO: fix depth of field effect!!!
void get_ray(inout Ray ray, in vec3 cam_pos, in ivec2 pixel_coords, in vec2 pixel_position, uint random_seed) {
	// uint unique_seed = random_seed + pixel_coords.x + pixel_coords.y;

	vec3 ray_origin_offset = random_in_unit_disk(random_seed) * aperture / 2;

	ray_origin_offset = (vec4(ray_origin_offset, 0.0) * cameraMatrix).xyz;

	vec2 ray_coords = vec2(pixel_position.x + (randomFloat(random_seed)) / resolution.x,
						   pixel_position.y + (randomFloat(random_seed)) / resolution.y);

	// vec3 ray_dir = normalize(lerp4vec(vv00, vv10, vv01, vv11, ray_coords.x, ray_coords.y) - ray_origin_offset);

	// ray = Ray(cam_pos + ray_origin_offset, ray_dir, vec3(1.0));

	ray_coords = ray_coords * 2. - 1.;

	vec3 ray_dir = normalize((vec4(ray_coords.x, -ray_coords.y * aspect, -1 / tan(fov / 2) * aspect, 0.0) * cameraMatrix).xyz);

	ray = Ray(cam_pos, ray_dir, vec3(1.0));
}

uniform vec3 sun_direction = normalize(vec3(1., 2., 1.));

void main() {
	vec4  pixel			 = vec4(0.0, 0.0, 0.0, 1.0);			// the pixel value
	ivec2 pixel_coords	 = ivec2(gl_GlobalInvocationID.xy);		// the pixel position of the current 'fragment'
	vec2  pixel_position = pixel_coords / resolution;			// pixel position mapped to [0, 1)

	// get the unique random seed for the pixel.
	uint random_seed_full = pixel_coords.x + pixel_coords.y * uint(resolution.x) + random_seed;
	// uint random_seed_full = random_seed;

	// int ray_id = to1d(pixel_coords, ivec2(resolution)); // position of the current ray in the ssbo
	Ray ray;	 // the current ray being traced
	get_ray(ray, cam_pos, pixel_coords, pixel_position, random_seed_full);

	for (int i = 0; i < max_bounces; i++) {
		// initialize the hit object
		RayHit hit;
		hit.dist = 1.0 / 0.0;

		// test intersections
		intersect_scene(ray, hit);

		if (hit.dist < 1.0 / 0.0) {		// if the ray hit anything, handle materials
			hit.pos = ray.origin + hit.dist * ray.direction;

			// if we are exiting a transparent material, use the transparency
			if (!hit.is_front_face) { ray.attenuation *= exp(-hit.mat.transparency_color * hit.dist); }

			float eta = pow(hit.mat.ior, float(!hit.is_front_face) * 2.0 - 1.0);

			float refraction_chance;
			float diffuse_chance;

			float frensel = schlick_reflectance(ray.direction, hit.normal, eta);	 // chance to specular if refracting

			// specular, but only when refracting
			float specular_1  = frensel * hit.mat.refraction_chance;
			refraction_chance = hit.mat.refraction_chance - specular_1;

			float specular_2 = (1. - hit.mat.refraction_chance) * hit.mat.specular_chance;
			diffuse_chance	 = (1 - hit.mat.refraction_chance) - specular_2;

			float cos_theta		 = min(dot(-ray.direction, hit.normal), 1.0);
			float sin_theta		 = sqrt(1.0 - cos_theta * cos_theta);
			bool  cannot_refract = eta * sin_theta > 1.0;

			float dice = randomFloat(random_seed_full);
			if (dice < diffuse_chance) {
				// diffuse reflection
				ray = disperse_reflect(ray, hit, hit.mat.albedo, 1.0, random_seed_full);
			} else if (dice < diffuse_chance + specular_1 + specular_2 || cannot_refract) {
				// specular reflection
				ray = disperse_reflect(ray, hit, hit.mat.albedo, hit.mat.specular_roughness, random_seed_full);
			} else {
				// refraction
				ray = disperse_refract(ray, hit, eta, random_seed_full);
			}

			pixel += vec4(hit.mat.emission * ray.attenuation, 0);

			// RayHit shadowHit;
			// shadowHit.dist = 1.0 / 0.0;
			// Ray shadowRay = Ray(hit.pos, sun_direction, vec3(1.0));
			// intersect_scene(shadowRay, shadowHit);
			// if(shadowHit.dist == 1.0 / 0.0) {
			// 	pixel += vec4(vec3(0.2) * ray.attenuation, 0);
			// }

			if (max(ray.attenuation.x, max(ray.attenuation.y, ray.attenuation.z)) < 0.01) break;

		} else {	 // if the ray hit nothing, write the sky color and deactivate the ray
			pixel += vec4(get_sky_color(ray) * ray.attenuation, 1.0);
			break;
		}
	}

	write_sample(pixel_coords, pixel);
}
